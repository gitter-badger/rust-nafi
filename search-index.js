var searchIndex = {};
searchIndex["nafi_lexer"] = {"doc":"Transformation of NAFI source code into tokens","items":[[4,"Token","nafi_lexer","",null,null],[13,"Whitespace","","",0,null],[13,"IntegerLiteral","","",0,null],[13,"StringLiteral","","",0,null],[5,"lex","","Lex NAFI source into its component tokens",null,{"inputs":[{"name":"str"}],"output":{"name":"vec"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"token"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}]],"paths":[[4,"Token"]]};
searchIndex["nafi_tokens"] = {"doc":"Tokens of Nafi source","items":[[3,"StringFragments","nafi_tokens","A String that also remembers invalid escapes inside it.",null,null],[3,"InvalidEscapes","","The invalid escapes in a string literal.",null,null],[4,"Token","","",null,null],[13,"Whitespace","","",0,null],[13,"IntegerLiteral","","",0,null],[13,"StringLiteral","","",0,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"token"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"token"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"stringfragments"}}],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",1,{"inputs":[],"output":{"name":"stringfragments"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"stringfragments"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"stringfragments"}],"output":{"name":"bool"}}],[11,"new","","Create a new, empty string.",1,{"inputs":[],"output":{"name":"stringfragments"}}],[11,"push","","Push a character onto the end of this string.",1,{"inputs":[{"name":"self"},{"name":"char"}],"output":null}],[11,"push_str","","Push a string onto the end of this string.",1,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"push_invalid_escape","","Push an invalid escape onto the end of this string.",1,{"inputs":[{"name":"self"},{"name":"s"}],"output":null}],[11,"try_into_string","","Try to turn this string into a normal string.",1,{"inputs":[{"name":"self"}],"output":{"name":"result"}}],[11,"clone","","",2,{"inputs":[{"name":"self"}],"output":{"name":"invalidescapes"}}],[11,"fmt","","",2,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",2,{"inputs":[{"name":"self"},{"name":"invalidescapes"}],"output":{"name":"bool"}}],[11,"ne","","",2,{"inputs":[{"name":"self"},{"name":"invalidescapes"}],"output":{"name":"bool"}}],[11,"iter","","Create an iterator over the invalid escapes.",2,null],[11,"from","","",1,{"inputs":[{"name":"str"}],"output":{"name":"self"}}]],"paths":[[4,"Token"],[3,"StringFragments"],[3,"InvalidEscapes"]]};
searchIndex["nnom"] = {"doc":"A minimal presentation of a nom-like parser combinator framework.","items":[[0,"combinators","nnom","Simple combinator fn of other parser fn",null,null],[5,"many0","nnom::combinators","Construct a new parser that matches a subparser zero or more times.",null,null],[5,"peek","","Run a parser without consuming anything.",null,null],[0,"result","nnom","Parsing result types",null,null],[3,"ParseOutput","nnom::result","The output of a parser fragment.",null,null],[12,"remaining_input","","Unused input given to the parser that produced this output",0,null],[12,"output","","The transformed output from the parser that produced this output",0,null],[6,"Result","","Standard result type for parsing.",null,null],[11,"clone","","",0,{"inputs":[{"name":"self"}],"output":{"name":"parseoutput"}}],[11,"fmt","","",0,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"default","","",0,{"inputs":[],"output":{"name":"parseoutput"}}],[11,"eq","","",0,{"inputs":[{"name":"self"},{"name":"parseoutput"}],"output":{"name":"bool"}}],[11,"ne","","",0,{"inputs":[{"name":"self"},{"name":"parseoutput"}],"output":{"name":"bool"}}],[0,"slice","nnom","Types for working with slices while retaining position information",null,null],[3,"PositionedIndex","nnom::slice","A slice with additional information of where it starts in the source buffer.",null,null],[6,"PositionedStr","","A string slice with associated start position in the original source slice.",null,null],[6,"PositionedSlice","","An array slice with associated start position in the original source slice.",null,null],[11,"fmt","","",1,{"inputs":[{"name":"self"},{"name":"formatter"}],"output":{"name":"result"}}],[11,"eq","","",1,{"inputs":[{"name":"self"},{"name":"positionedindex"}],"output":{"name":"bool"}}],[11,"ne","","",1,{"inputs":[{"name":"self"},{"name":"positionedindex"}],"output":{"name":"bool"}}],[11,"clone","","",1,{"inputs":[{"name":"self"}],"output":{"name":"self"}}],[11,"deref","","",1,null],[11,"new","","Create a new positioned slice from a raw slice and start position",1,{"inputs":[{"name":"t"},{"name":"usize"}],"output":{"name":"self"}}],[11,"start","","The starting index of this slice.",1,{"inputs":[{"name":"self"}],"output":{"name":"usize"}}],[11,"split_at","","Split the slice into two parts around a given index.",1,null],[11,"from","","",2,{"inputs":[{"name":"str"}],"output":{"name":"self"}}],[11,"from","","",3,null],[0,"prelude","nnom","The commonly used types of this crate",null,null]],"paths":[[3,"ParseOutput"],[3,"PositionedIndex"],[6,"PositionedStr"],[6,"PositionedSlice"]]};
initSearch(searchIndex);
